<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Agentic System Demo - Trợ lý Chủ động</title>
    <!-- TailwindCSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Marked.js CDN -->
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <!-- Lucide Icons CDN -->
    <script src="https://unpkg.com/lucide@latest"></script>
    <!-- FullCalendar CDN -->
    <script src='https://cdn.jsdelivr.net/npm/fullcalendar@6.1.11/index.global.min.js'></script>
    <style>
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        @keyframes pulse { 0%, 100% { transform: scale(1); box-shadow: 0 0 0 0 rgba(239, 68, 68, 0.7); } 50% { transform: scale(1.05); box-shadow: 0 0 0 10px rgba(239, 68, 68, 0); } }
        .spinner { border: 4px solid rgba(255, 255, 255, 0.3); border-left-color: #fff; border-radius: 50%; width: 20px; height: 20px; animation: spin 1s linear infinite; }
        .hidden { display: none; }
        .mic-btn.listening { animation: pulse 1.5s infinite; background-color: #fee2e2; color: #ef4444; }
        
        /* Chat styles */
        #chat-container { scroll-behavior: smooth; }
        .chat-bubble { max-width: 85%; }
        .chat-bubble-user { background-color: #3b82f6; color: white; }
        .chat-bubble-ai { background-color: #f3f4f6; color: #1f2937; }
        .prose { max-width: 100%; }
        .prose p:first-child { margin-top: 0; }
        .prose p:last-child { margin-bottom: 0; }

        /* FullCalendar custom styles */
        :root { --fc-border-color: #e5e7eb; --fc-today-bg-color: #eff6ff; }
        .fc .fc-button-primary { background-color: #3b82f6; border-color: #3b82f6; }
        .fc .fc-button-primary:hover { background-color: #2563eb; border-color: #2563eb; }
        .fc-event { font-size: 0.8rem !important; }
        .tab-btn { transition: all 0.2s ease-in-out; }
        .tab-btn.active { border-color: #3b82f6; color: #3b82f6; background-color: #eff6ff; }

        /* Modal styles */
        #customModal { transition: opacity 0.3s ease; }
    </style>
</head>
<body class="bg-gray-100 flex flex-col items-center h-screen p-2 sm:p-4">

    <!-- Auth Container -->
    <div id="authContainer" class="w-full max-w-md mx-auto my-auto">
        <!-- Auth UI will be injected here -->
    </div>

    <!-- App Container -->
    <div id="appContainer" class="hidden w-full max-w-3xl h-full flex flex-col bg-white rounded-xl shadow-lg">
        <header class="p-4 border-b flex justify-between items-center flex-shrink-0">
            <div>
                <p class="text-sm text-gray-600">Đã đăng nhập với:</p>
                <p id="userEmail" class="font-semibold text-gray-800"></p>
            </div>
            <button id="logoutButton" class="px-4 py-2 bg-red-500 text-white text-sm font-semibold rounded-lg hover:bg-red-600">Đăng xuất</button>
        </header>

        <main id="chat-container" class="flex-grow p-4 space-y-4 overflow-y-auto">
            <!-- Chat messages will be appended here -->
        </main>

        <footer id="controls" class="p-4 border-t bg-gray-50 rounded-b-xl flex-shrink-0">
            <div class="relative">
                <textarea id="promptInput" rows="1" class="w-full p-3 pr-14 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 resize-none" placeholder="Thử: 'việc nào quan trọng nhất?'" disabled></textarea>
                <button id="micButton" title="Bắt đầu ghi âm" class="mic-btn absolute right-2 top-1/2 -translate-y-1/2 p-2 rounded-full text-gray-500 hover:bg-gray-100 hover:text-blue-600 transition-colors" disabled>
                    <i data-lucide="mic" class="w-5 h-5"></i>
                </button>
            </div>
            
            <div id="quickActions" class="mt-2 flex items-center justify-center gap-2">
                <button id="quickActionAllNotes" class="px-3 py-1 bg-gray-200 text-gray-700 text-sm rounded-full hover:bg-gray-300 transition-colors">Tất cả ghi chú</button>
                <button id="quickActionAllReminders" class="px-3 py-1 bg-gray-200 text-gray-700 text-sm rounded-full hover:bg-gray-300 transition-colors">Tất cả lời nhắc</button>
            </div>

            <button id="sendPromptButton" class="mt-2 w-full flex justify-center items-center gap-3 px-4 py-3 bg-blue-600 text-white font-semibold rounded-lg shadow-md hover:bg-blue-700 disabled:bg-blue-300" disabled>
                <span id="buttonText">Gửi</span>
                <div id="buttonSpinner" class="spinner hidden"></div>
            </button>
             <p id="statusMessage" class="mt-2 text-center text-sm h-5"></p>
        </footer>
    </div>

    <!-- Custom Modal -->
    <div id="customModal" class="fixed inset-0 bg-gray-800 bg-opacity-60 overflow-y-auto h-full w-full hidden z-50 flex items-center justify-center">
        <div id="modalContentContainer" class="relative mx-auto p-6 border w-full max-w-md shadow-lg rounded-xl bg-white transform transition-all scale-95 opacity-0">
            <h3 class="text-xl text-center font-semibold text-gray-900" id="modalTitle"></h3>
            <div class="mt-4" id="modalBody">
                <!-- Modal content (message or input) goes here -->
            </div>
            <div class="mt-6 flex justify-end space-x-3" id="modalActions">
                <!-- Modal buttons go here -->
            </div>
        </div>
    </div>


    <script type="module">
        // --- Firebase and DOM Elements ---
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.9.0/firebase-app.js";
        import { getAI, getGenerativeModel, GoogleAIBackend } from "https://www.gstatic.com/firebasejs/11.9.0/firebase-ai.js";
        import { getFirestore, collection, addDoc, getDocs, query, orderBy, doc, deleteDoc, updateDoc, where } from "https://www.gstatic.com/firebasejs/11.9.0/firebase-firestore.js";
        import { getAuth, createUserWithEmailAndPassword, signInWithEmailAndPassword, signOut, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.9.0/firebase-auth.js";

        const firebaseConfig = {
            apiKey: "AIzaSyAEOby-OTFXDQZTAc8M_b0OUxC1A00FfpE",
            authDomain: "webauto-5a5ba.firebaseapp.com",
            projectId: "webauto-5a5ba",
            storageBucket: "webauto-5a5ba.appspot.com",
            messagingSenderId: "862713453746",
            appId: "1:862713453746:web:bebc7edb492ad5cb01fdab"
        };
        const app = initializeApp(firebaseConfig);
        const db = getFirestore(app);
        const auth = getAuth(app);
        
        const authContainer = document.getElementById('authContainer');
        authContainer.innerHTML = `<div class="bg-white p-8 rounded-xl shadow-lg"><div id="loginView"><h2 class="text-2xl font-bold text-center text-gray-800 mb-6">Đăng nhập</h2><form id="loginForm" class="space-y-4"><input type="email" id="loginEmail" placeholder="Email" class="w-full p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500" required><input type="password" id="loginPassword" placeholder="Mật khẩu" class="w-full p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500" required><button type="submit" class="w-full py-3 bg-blue-600 text-white font-semibold rounded-lg shadow-md hover:bg-blue-700">Đăng nhập</button></form><p class="text-center text-sm text-gray-600 mt-4">Chưa có tài khoản? <a href="#" id="showSignup" class="font-medium text-blue-600 hover:underline">Đăng ký</a></p></div><div id="signupView" class="hidden"><h2 class="text-2xl font-bold text-center text-gray-800 mb-6">Đăng ký</h2><form id="signupForm" class="space-y-4"><input type="email" id="signupEmail" placeholder="Email" class="w-full p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500" required><input type="password" id="signupPassword" placeholder="Mật khẩu (ít nhất 6 ký tự)" class="w-full p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500" required><button type="submit" class="w-full py-3 bg-green-600 text-white font-semibold rounded-lg shadow-md hover:bg-green-700">Đăng ký</button></form><p class="text-center text-sm text-gray-600 mt-4">Đã có tài khoản? <a href="#" id="showLogin" class="font-medium text-blue-600 hover:underline">Đăng nhập</a></p></div><p id="authError" class="text-red-500 text-sm text-center mt-4 h-4"></p></div>`;

        const appContainer = document.getElementById('appContainer');
        const userEmail = document.getElementById('userEmail');
        const chatContainer = document.getElementById('chat-container');
        const promptInput = document.getElementById('promptInput');
        const sendPromptButton = document.getElementById('sendPromptButton');
        const micButton = document.getElementById('micButton');
        const statusMessage = document.getElementById('statusMessage');
        const customModal = document.getElementById('customModal');
        const modalContentContainer = document.getElementById('modalContentContainer');
        const modalTitle = document.getElementById('modalTitle');
        const modalBody = document.getElementById('modalBody');
        const modalActions = document.getElementById('modalActions');

        let model, chat, currentUser, reminderIntervalId;
        let conversationContext = null;

        // --- AI Keyword Expansion Helper ---
        async function generateKeywordsWithAI(text) {
            if (!model) return text.toLowerCase().split(' ').filter(Boolean);
            try {
                const prompt = `Với câu sau: "${text}", hãy liệt kê các từ khóa, từ đồng nghĩa và khái niệm liên quan để tìm kiếm sau này. Chỉ trả về danh sách các từ, viết thường, ngăn cách bởi dấu phẩy, không giải thích gì thêm.`;
                const result = await model.generateContent(prompt);
                const response = result.response;
                const keywordsText = response.text();
                const baseKeywords = text.toLowerCase().split(' ').filter(Boolean);
                const aiKeywords = keywordsText.split(',').map(k => k.trim()).filter(Boolean);
                const allKeywords = new Set([...baseKeywords, ...aiKeywords]);
                return Array.from(allKeywords);
            } catch (error) {
                console.error("Lỗi khi tạo từ khóa bằng AI:", error);
                return text.toLowerCase().split(' ').filter(Boolean);
            }
        }

        // --- Auth State Management ---
        onAuthStateChanged(auth, async user => {
            currentUser = user;
            if (user) {
                authContainer.classList.add('hidden');
                appContainer.classList.remove('hidden');
                userEmail.textContent = user.email;
                chatContainer.innerHTML = '';
                await initializeSystems(); 
            } else {
                authContainer.classList.remove('hidden');
                appContainer.classList.add('hidden');
                chat = null;
                conversationContext = null;
                if (reminderIntervalId) clearInterval(reminderIntervalId);
            }
        });
        
        async function initializeSystems() {
            setControlsEnabled(false, 'Đang khởi tạo AI...');
            try {
                await initializeAIModel();
                initializeSpeechRecognition();
                startReminderChecker();
                await triggerDailySummary(); // Trigger proactive summary
                setControlsEnabled(true);
            } catch (e) {
                appendAIMessage({ type: 'message', data: `**Lỗi nghiêm trọng khi khởi tạo:** ${e.message}` });
                setControlsEnabled(false, 'Lỗi khởi tạo');
            }
        }

        // --- Agent Functions ---
        const agentFunctions = {
          async saveNote(args) {
            if (!currentUser) return { type: 'message', data: 'Lỗi: Vui lòng đăng nhập.' };
            const notesCollection = collection(db, 'users', currentUser.uid, 'notes');
            const text = args.text || '';
            const keywords = await generateKeywordsWithAI(text);
            await addDoc(notesCollection, { 
                text: text, 
                createdAt: new Date(),
                priority: args.priority || 'medium',
                keywords: keywords
            });
            return { type: 'message', data: `✅ Đã lưu ghi chú: "${args.text}"` };
          },
          async getAllNotesFromFirestore() {
            if (!currentUser) return { type: 'message', data: 'Lỗi: Vui lòng đăng nhập.' };
            const notesCollection = collection(db, 'users', currentUser.uid, 'notes');
            const q = query(notesCollection, orderBy("createdAt", "desc"));
            const snapshot = await getDocs(q);
            let notes = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
            notes = sortWithPriority(notes);
            if (notes.length === 0) return { type: 'message', data: "🤔 Bạn chưa có ghi chú nào." };
            return { type: 'notes', data: notes };
          },
          async searchNotes(args) {
            if (!currentUser) return { type: 'message', data: 'Lỗi: Vui lòng đăng nhập.' };
            const { query: searchQuery, startDate, endDate, priority } = args;
            if (!searchQuery && !startDate && !endDate && !priority) return this.getAllNotesFromFirestore();
            
            const notesCollection = collection(db, 'users', currentUser.uid, 'notes');
            let q;
            
            if (startDate && endDate) {
                q = query(notesCollection, 
                    where("createdAt", ">=", new Date(startDate)), 
                    where("createdAt", "<=", new Date(endDate)), 
                    orderBy("createdAt", "desc"));
            } else {
                 q = query(notesCollection, orderBy("createdAt", "desc"));
            }

            const snapshot = await getDocs(q);
            let results = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));

            if (priority) {
                results = results.filter(note => (note.priority || 'medium') === priority);
            }
            if (searchQuery) {
                const searchTerms = searchQuery.toLowerCase().split(' ').filter(Boolean);
                results = results.filter(note => 
                    searchTerms.every(term => (note.keywords || []).includes(term))
                );
            }

            if (results.length === 0) return { type: 'message', data: `🤔 Tôi không tìm thấy ghi chú nào phù hợp.` };
            
            results = sortWithPriority(results);
            return { type: 'notes', data: results };
          },
          async deleteNoteFromFirestore(args) {
             if (!currentUser) return { type: 'message', data: 'Lỗi: Vui lòng đăng nhập.' };
             const noteRef = doc(db, 'users', currentUser.uid, 'notes', args.id);
             await deleteDoc(noteRef);
             return this.getAllNotesFromFirestore();
          },
          async updateNoteInFirestore(args) {
             if (!currentUser) return { type: 'message', data: 'Lỗi: Vui lòng đăng nhập.' };
             const noteRef = doc(db, 'users', currentUser.uid, 'notes', args.id);
             const updateData = {};
             if (args.newText) {
                updateData.text = args.newText;
                updateData.keywords = await generateKeywordsWithAI(args.newText);
             }
             if (args.newPriority) updateData.priority = args.newPriority;
             await updateDoc(noteRef, updateData);
             return this.getAllNotesFromFirestore();
          },
          async createReminder(args) {
            if (!currentUser) return { type: 'message', data: 'Lỗi: Vui lòng đăng nhập.' };
            const remindersCollection = collection(db, 'users', currentUser.uid, 'reminders');
            const title = args.title || '';
            const keywords = await generateKeywordsWithAI(title);
            await addDoc(remindersCollection, { 
                title: title, 
                reminderTime: new Date(args.reminderTime),
                createdAt: new Date(),
                triggered: false,
                priority: args.priority || 'medium',
                keywords: keywords
            });
            return { type: 'message', data: `✅ Đã tạo lời nhắc: "${args.title}"` };
          },
          async getAllRemindersFromFirestore() {
            if (!currentUser) return { type: 'message', data: 'Lỗi: Vui lòng đăng nhập.' };
            const remindersCollection = collection(db, 'users', currentUser.uid, 'reminders');
            const q = query(remindersCollection, orderBy("reminderTime", "asc"));
            const snapshot = await getDocs(q);
            let reminders = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
            reminders = sortWithPriority(reminders);
            if (reminders.length === 0) return { type: 'message', data: "🤔 Bạn chưa có lời nhắc nào." };
            return { type: 'reminders', data: reminders };
          },
          async searchReminders(args) {
            if (!currentUser) return { type: 'message', data: 'Lỗi: Vui lòng đăng nhập.' };
            const { query: searchQuery, startDate, endDate, priority } = args;

            if (!searchQuery && !startDate && !endDate && !priority) return this.getAllRemindersFromFirestore();

            const remindersCollection = collection(db, 'users', currentUser.uid, 'reminders');
            let q;

            if (startDate && endDate) {
                q = query(remindersCollection,
                    where("reminderTime", ">=", new Date(startDate)),
                    where("reminderTime", "<=", new Date(endDate)),
                    orderBy("reminderTime", "asc"));
            } else {
                q = query(remindersCollection, orderBy("reminderTime", "asc"));
            }

            const snapshot = await getDocs(q);
            let results = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));

            if (priority) {
                results = results.filter(reminder => (reminder.priority || 'medium') === priority);
            }
            if (searchQuery) {
                const searchTerms = searchQuery.toLowerCase().split(' ').filter(Boolean);
                results = results.filter(reminder =>
                    searchTerms.every(term => (reminder.keywords || []).includes(term))
                );
            }

            if (results.length === 0) return { type: 'message', data: `🤔 Tôi không tìm thấy lời nhắc nào phù hợp.` };
            
            results = sortWithPriority(results);
            return { type: 'reminders', data: results };
          },
          async updateReminderInFirestore(args) {
             if (!currentUser) return { type: 'message', data: 'Lỗi: Vui lòng đăng nhập.' };
             const reminderRef = doc(db, 'users', currentUser.uid, 'reminders', args.id);
             const updateData = {};
             if (args.newTitle) {
                updateData.title = args.newTitle;
                updateData.keywords = await generateKeywordsWithAI(args.newTitle);
             }
             if (args.newTime) updateData.reminderTime = new Date(args.newTime);
             if (args.newPriority) updateData.priority = args.newPriority;
             if (Object.keys(updateData).length > 0) {
                await updateDoc(reminderRef, updateData);
             }
             return this.getAllRemindersFromFirestore();
          },
          async deleteReminderFromFirestore(args) {
             if (!currentUser) return { type: 'message', data: 'Lỗi: Vui lòng đăng nhập.' };
             const reminderRef = doc(db, 'users', currentUser.uid, 'reminders', args.id);
             await deleteDoc(reminderRef);
             return this.getAllRemindersFromFirestore();
          },
          async getEventsForCalendar() {
            if (!currentUser) return { type: 'message', data: 'Lỗi: Vui lòng đăng nhập.' };
            const remindersCollection = collection(db, 'users', currentUser.uid, 'reminders');
            const q = query(remindersCollection, orderBy("reminderTime", "asc"));
            const snapshot = await getDocs(q);
            const events = snapshot.docs.map(doc => {
                const reminder = doc.data();
                const priorityColors = { high: '#ef4444', medium: '#f59e0b', low: '#6b7280' };
                return { id: doc.id, title: reminder.title, start: reminder.reminderTime.toDate().toISOString(), allDay: false, color: reminder.triggered ? '#a3a3a3' : (priorityColors[reminder.priority] || '#3b82f6') };
            });
            return { type: 'calendar', data: events };
          },
          // New function for proactive assistant
          async getUpcomingSchedule() {
            if (!currentUser) return { type: 'message', data: 'Lỗi: Vui lòng đăng nhập.' };
            const now = new Date();
            const tomorrow = new Date(now.getTime() + 48 * 60 * 60 * 1000); // 48 hours from now

            const remindersCollection = collection(db, 'users', currentUser.uid, 'reminders');
            const q = query(remindersCollection, 
                where("reminderTime", ">=", now), 
                where("reminderTime", "<=", tomorrow),
                orderBy("reminderTime", "asc"));
            
            const snapshot = await getDocs(q);
            if (snapshot.empty) {
                return { type: 'message', data: "Không có lịch trình nào trong 48 giờ tới." };
            }
            const schedule = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
            return { type: 'schedule', data: schedule };
          }
        };
        const tools = [{ functionDeclarations: [
            { name: "saveNote", description: "Lưu một ghi chú cá nhân cho người dùng.", parameters: { type: "object", properties: { "text": { "type": "string" }, "priority": { "type": "string", "enum": ["high", "medium", "low"], "description": "Mức độ ưu tiên." } }, required: ["text"] } },
            { name: "getAllNotesFromFirestore", description: "Lấy và hiển thị TẤT CẢ các ghi chú cá nhân của người dùng.", parameters: { type: "object", properties: {} } },
            { name: "searchNotes", description: "Tìm kiếm và lấy thông tin từ ghi chú cá nhân của người dùng. Đây là công cụ chính để trả lời các câu hỏi về ghi chú đã lưu. Nếu người dùng chỉ hỏi về thời gian/độ ưu tiên mà không có chủ đề cụ thể, hãy bỏ trống tham số 'query'.", parameters: { type: "object", properties: { "query": { "type": "string", "description": "Chủ đề hoặc nội dung chính cần tìm trong ghi chú." }, "startDate": { "type": "string", "description": "Ngày bắt đầu để tìm kiếm (ngày tạo ghi chú), định dạng ISO 8601." }, "endDate": { "type": "string", "description": "Ngày kết thúc để tìm kiếm (ngày tạo ghi chú), định dạng ISO 8601." }, "priority": { "type": "string", "enum": ["high", "medium", "low"], "description": "Lọc theo mức độ ưu tiên." } } } },
            { name: "deleteNoteFromFirestore", description: "Xóa một ghi chú cá nhân của người dùng dựa trên ID.", parameters: { type: "object", properties: { "id": { "type": "string" } }, required: ["id"] } },
            { name: "updateNoteInFirestore", description: "Cập nhật nội dung và/hoặc độ ưu tiên của một ghi chú cá nhân của người dùng.", parameters: { type: "object", properties: { "id": { "type": "string" }, "newText": { "type": "string" }, "newPriority": { "type": "string", "enum": ["high", "medium", "low"] } }, required: ["id"] } },
            { name: "createReminder", description: "Tạo một lịch hẹn hoặc lời nhắc cá nhân cho người dùng.", parameters: { type: "object", properties: { "title": { "type": "string" }, "reminderTime": { "type": "string", "description": "Thời gian nhắc, định dạng ISO 8601." }, "priority": { "type": "string", "enum": ["high", "medium", "low"], "description": "Mức độ ưu tiên." } }, required: ["title", "reminderTime"] } },
            { name: "getAllRemindersFromFirestore", description: "Lấy và hiển thị TẤT CẢ các lời nhắc cá nhân của người dùng.", parameters: { type: "object", properties: {} } },
            { name: "searchReminders", description: "Tìm kiếm và lấy thông tin từ lời nhắc cá nhân của người dùng. Đây là công cụ chính để trả lời các câu hỏi về lời nhắc đã lưu (ví dụ: 'mấy giờ bay?'). Nếu người dùng chỉ hỏi về thời gian/độ ưu tiên mà không có chủ đề cụ thể, hãy bỏ trống tham số 'query'.", parameters: { type: "object", properties: { "query": { "type": "string", "description": "Chủ đề hoặc nội dung chính cần tìm trong lời nhắc." }, "startDate": { "type": "string", "description": "Ngày bắt đầu để tìm kiếm (ngày hẹn), định dạng ISO 8601." }, "endDate": { "type": "string", "description": "Ngày kết thúc để tìm kiếm (ngày hẹn), định dạng ISO 8601." }, "priority": { "type": "string", "enum": ["high", "medium", "low"], "description": "Lọc theo mức độ ưu tiên." } } } },
            { name: "updateReminderInFirestore", description: "Cập nhật nội dung, thời gian và/hoặc độ ưu tiên của một lời nhắc cá nhân của người dùng.", parameters: { type: "object", properties: { "id": { "type": "string" }, "newTitle": { "type": "string" }, "newTime": { "type": "string", "description": "Thời gian mới, định dạng ISO 8601."}, "newPriority": { "type": "string", "enum": ["high", "medium", "low"] } }, required: ["id"] } },
            { name: "deleteReminderFromFirestore", description: "Xóa một lời nhắc cá nhân của người dùng dựa trên ID.", parameters: { type: "object", properties: { "id": { "type": "string" } }, required: ["id"] } },
            { name: "getEventsForCalendar", description: "Lấy tất cả sự kiện, lời nhắc cá nhân của người dùng để hiển thị trên lịch.", parameters: { type: "object", properties: {} } }
        ] }];

        // --- Initializations (AI, Reminders, Speech) ---
        async function initializeAIModel() {
            if (chat) return;
            const ai = getAI(app, { backend: new GoogleAIBackend() });
            model = getGenerativeModel(ai, { model: "gemini-2.5-flash" });
            chat = model.startChat({ tools: tools });
        }
        function startReminderChecker() {
            if ('Notification' in window && Notification.permission !== 'granted') { Notification.requestPermission(); }
            if (reminderIntervalId) clearInterval(reminderIntervalId);
            reminderIntervalId = setInterval(async () => {
                if (!currentUser) return;
                const remindersCollection = collection(db, 'users', currentUser.uid, 'reminders');
                const q = query(remindersCollection, where("reminderTime", "<=", new Date()), where("triggered", "==", false));
                const snapshot = await getDocs(q);
                snapshot.forEach(docSnapshot => {
                    const reminder = { id: docSnapshot.id, ...docSnapshot.data() };
                    if (Notification.permission === 'granted') {
                        new Notification('Lời nhắc đến hạn!', { body: reminder.title, icon: 'https://img.icons8.com/color/48/appointment-reminders--v1.png' });
                    }
                    const reminderRef = doc(db, 'users', currentUser.uid, 'reminders', reminder.id);
                    updateDoc(reminderRef, { triggered: true });
                });
            }, 30000);
        }
        function initializeSpeechRecognition() {
            const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
            if (!SpeechRecognition) {
                micButton.disabled = true;
                micButton.title = "Trình duyệt không hỗ trợ nhận dạng giọng nói";
                return;
            }
            const recognition = new SpeechRecognition();
            recognition.lang = 'vi-VN';
            recognition.interimResults = false;
            micButton.addEventListener('click', () => {
                micButton.classList.add('listening');
                micButton.title = "Đang lắng nghe...";
                statusMessage.textContent = 'Xin mời nói...';
                recognition.start();
            });
            recognition.onresult = (event) => {
                const transcript = event.results[0][0].transcript;
                promptInput.value = transcript;
                setTimeout(() => handlePrompt(), 200);
            };
            recognition.onerror = (event) => {
                statusMessage.textContent = `Lỗi nhận dạng: ${event.error}`;
            };
            recognition.onend = () => {
                micButton.classList.remove('listening');
                micButton.title = "Bắt đầu ghi âm";
            };
        }
        
        // --- Proactive Assistant ---
        async function triggerDailySummary() {
            appendTypingIndicator();
            const scheduleResult = await agentFunctions.getUpcomingSchedule();
            removeTypingIndicator();

            if (scheduleResult.type === 'message') { // No events
                appendAIMessage({ type: 'message', data: `Chào buổi sáng! Hôm nay bạn có một ngày khá trống trải. Bạn muốn bắt đầu với việc gì?` });
                return;
            }

            const context = `Dữ liệu lịch trình sắp tới của người dùng:\n` + 
                          scheduleResult.data.map(item => {
                              const content = item.text || item.title;
                              const time = `Thời gian: ${item.reminderTime.toDate().toLocaleString('vi-VN')}`;
                              const priority = `Ưu tiên: ${item.priority || 'trung bình'}`;
                              return `- Nội dung: "${content}", ${time}, ${priority}`;
                          }).join('\n');

            const summarizationPrompt = `Bạn là một trợ lý ảo chủ động và thông minh. Bây giờ là buổi sáng. Dựa vào lịch trình sau của người dùng:\n${context}\n\nHãy chào buổi sáng người dùng và đưa ra một bản tóm tắt ngắn gọn về ngày hôm nay và ngày mai. Phân tích xem có xung đột nào không, lịch trình có quá dày đặc không, và gợi ý những việc cần chuẩn bị. Trả lời một cách thân thiện và chủ động.`;
            
            appendTypingIndicator();
            const summaryResult = await model.generateContent(summarizationPrompt);
            const summaryResponse = summaryResult.response;
            removeTypingIndicator();
            appendAIMessage({ type: 'message', data: summaryResponse.text() });
        }


        // --- Main Prompt Handling Logic ---
        async function handlePrompt() {
            const promptText = promptInput.value.trim();
            if (!promptText || !chat) return;

            setControlsEnabled(false);
            appendUserMessage(promptText);
            promptInput.value = '';
            appendTypingIndicator();

            try {
                const now = new Date();
                const formattedDate = now.toLocaleString('vi-VN', { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric', hour: '2-digit', minute: '2-digit' });
                
                let fullPrompt = `Bối cảnh: Thời gian hiện tại là ${formattedDate}. Dựa vào thông tin này, hãy thực hiện yêu cầu sau của người dùng: "${promptText}"`;
                
                if (conversationContext) {
                    fullPrompt = `Dựa vào ngữ cảnh sau đây:\n${conversationContext}\n\nHãy trả lời câu hỏi tiếp theo của người dùng: "${promptText}"`;
                }

                let result = await chat.sendMessage(fullPrompt);
                let response = result.response;
                let functionCalls = response.functionCalls();
                
                let searchResultData = null;
                let searchResultType = null;

                if (functionCalls && functionCalls.length > 0) {
                    const functionResponses = [];
                    for (const func of functionCalls) {
                        if (agentFunctions[func.name]) {
                            const functionResult = await agentFunctions[func.name](func.args);
                            
                            if (func.name.startsWith('search') && functionResult.type !== 'message') {
                                searchResultData = functionResult.data;
                                searchResultType = functionResult.type;
                            } else if (['notes', 'reminders', 'calendar'].includes(functionResult.type)) {
                                appendAIMessage(functionResult);
                                conversationContext = null;
                            }
                            
                            functionResponses.push({ functionResponse: { name: func.name, response: functionResult } });
                        }
                    }
                    
                    result = await chat.sendMessage(functionResponses);
                    response = result.response;
                }

                removeTypingIndicator();
                
                if (searchResultData) {
                    conversationContext = `Ngữ cảnh: Người dùng vừa tìm thấy ${searchResultType === 'notes' ? 'ghi chú' : 'lời nhắc'} sau:\n` + 
                                          searchResultData.map(item => `- Nội dung: "${item.text || item.title}"`).join('\n');
                    
                    appendAIMessage({ type: 'message', data: response.text() });
                    appendAIMessage({ type: searchResultType, data: searchResultData });
                } else {
                    conversationContext = null;
                    if(response.text()) {
                         appendAIMessage({ type: 'message', data: response.text() });
                    }
                }

            } catch (error) {
                appendAIMessage({ type: 'message', data: `**Lỗi:** ${error.message}.` });
                conversationContext = null;
            } finally {
                setControlsEnabled(true);
            }
        }

        // --- Chat UI and Modal Helper Functions ---
        function setControlsEnabled(enabled, status = '') {
            promptInput.disabled = !enabled;
            sendPromptButton.disabled = !enabled;
            micButton.disabled = !enabled;
            statusMessage.textContent = status;
        }
        function scrollToBottom() { chatContainer.scrollTop = chatContainer.scrollHeight; }
        function escapeHTML(str) {
            return str ? str.replace(/[&<>"']/g, match => ({ '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#39;' }[match])) : '';
        }
        function appendUserMessage(text) {
            const div = document.createElement('div');
            div.className = 'flex justify-end';
            div.innerHTML = `<div class="chat-bubble chat-bubble-user p-3 rounded-lg prose prose-invert max-w-full">${marked.parse(text)}</div>`;
            chatContainer.appendChild(div);
            scrollToBottom();
        }
        function appendAIMessage(response) {
            removeTypingIndicator();
            const div = document.createElement('div');
            div.className = 'flex justify-start';
            const bubble = document.createElement('div');
            bubble.className = 'chat-bubble chat-bubble-ai p-3 rounded-lg';
            renderResponseContent(bubble, response);
            div.appendChild(bubble);
            chatContainer.appendChild(div);
            scrollToBottom();
            if (typeof lucide !== 'undefined') {
                lucide.createIcons();
            }
        }
        function appendTypingIndicator() {
            if (document.getElementById('typing-indicator')) return;
            const div = document.createElement('div');
            div.id = 'typing-indicator';
            div.className = 'flex justify-start';
            div.innerHTML = `<div class="chat-bubble chat-bubble-ai p-3 rounded-lg flex items-center gap-2"><div class="w-2 h-2 bg-gray-400 rounded-full animate-bounce" style="animation-delay:-0.3s;"></div><div class="w-2 h-2 bg-gray-400 rounded-full animate-bounce" style="animation-delay:-0.15s;"></div><div class="w-2 h-2 bg-gray-400 rounded-full animate-bounce"></div></div>`;
            chatContainer.appendChild(div);
            scrollToBottom();
        }
        function removeTypingIndicator() {
            const indicator = document.getElementById('typing-indicator');
            if (indicator) indicator.remove();
        }
        function getPriorityClass(priority) {
            switch (priority) {
                case 'high': return 'border-l-4 border-red-500';
                case 'medium': return 'border-l-4 border-yellow-500';
                case 'low': return 'border-l-4 border-gray-400';
                default: return 'border-l-4 border-gray-200';
            }
        }
        function sortWithPriority(items) {
            const priorityOrder = { 'high': 3, 'medium': 2, 'low': 1 };
            return items.sort((a, b) => (priorityOrder[b.priority] || 0) - (priorityOrder[a.priority] || 0));
        }
        function createNoteCard(note) {
            const card = document.createElement('div');
            card.className = `bg-gray-50 p-4 rounded-lg flex justify-between items-start gap-4 ${getPriorityClass(note.priority)}`;
            card.innerHTML = `
                <div class="flex-grow">
                    <p class="text-gray-800">${note.text}</p>
                    <p class="text-xs text-gray-500 mt-2">Tạo lúc: ${formatTimestamp(note.createdAt.toDate())}</p>
                </div>
                <div class="flex-shrink-0 flex items-center gap-2">
                    <button data-note-id="${note.id}" data-note-text="${escapeHTML(note.text)}" data-note-priority="${note.priority || 'medium'}" title="Sửa ghi chú" class="edit-btn p-2 text-blue-500 hover:text-blue-700 hover:bg-blue-100 rounded-full"><i data-lucide="file-pen-line" class="w-4 h-4 pointer-events-none"></i></button>
                    <button data-note-id="${note.id}" title="Xóa ghi chú" class="delete-btn p-2 text-red-500 hover:text-red-700 hover:bg-red-100 rounded-full"><i data-lucide="trash-2" class="w-4 h-4 pointer-events-none"></i></button>
                </div>`;
            return card;
        }
        function createReminderCard(reminder) {
            const card = document.createElement('div');
            const isTriggered = reminder.triggered;
            const reminderDate = reminder.reminderTime.toDate();
            const localISOString = new Date(reminderDate.getTime() - (reminderDate.getTimezoneOffset() * 60000)).toISOString().slice(0, 16);
            card.className = `bg-yellow-50 p-4 rounded-lg flex justify-between items-start gap-4 ${getPriorityClass(reminder.priority)} ${isTriggered ? 'opacity-50' : ''}`;
            card.innerHTML = `
                <div class="flex-grow">
                    <p class="text-gray-800 font-medium ${isTriggered ? 'line-through' : ''}">${reminder.title}</p>
                    <p class="text-sm text-yellow-800 mt-1 flex items-center gap-2">
                        <i data-lucide="bell" class="w-4 h-4"></i>
                        <span>${formatTimestamp(reminderDate)}</span>
                    </p>
                </div>
                <div class="flex-shrink-0 flex items-center gap-2">
                    <button data-reminder-id="${reminder.id}" data-reminder-title="${escapeHTML(reminder.title)}" data-reminder-time="${localISOString}" data-reminder-priority="${reminder.priority || 'medium'}" title="Sửa lời nhắc" class="edit-reminder-btn p-2 text-blue-500 hover:text-blue-700 hover:bg-blue-100 rounded-full"><i data-lucide="file-pen-line" class="w-4 h-4 pointer-events-none"></i></button>
                    <button data-reminder-id="${reminder.id}" title="Xóa lời nhắc" class="delete-reminder-btn p-2 text-red-500 hover:text-red-700 hover:bg-red-100 rounded-full"><i data-lucide="trash-2" class="w-4 h-4 pointer-events-none"></i></button>
                </div>`;
            return card;
        }
        function renderResponseContent(container, response) {
            if (['notes', 'reminders', 'calendar'].includes(response.type)) {
                const activeTab = response.type;
                container.innerHTML = `
                    <div class="border-b border-gray-200 mb-4">
                        <nav class="-mb-px flex space-x-6" aria-label="Tabs">
                            <button data-type="notes" class="tab-btn whitespace-nowrap py-3 px-1 border-b-2 font-medium text-sm ${activeTab === 'notes' ? 'active' : 'border-transparent text-gray-500 hover:text-gray-700 hover:border-gray-300'}">Ghi chú</button>
                            <button data-type="reminders" class="tab-btn whitespace-nowrap py-3 px-1 border-b-2 font-medium text-sm ${activeTab === 'reminders' ? 'active' : 'border-transparent text-gray-500 hover:text-gray-700 hover:border-gray-300'}">Lời nhắc</button>
                            <button data-type="calendar" class="tab-btn whitespace-nowrap py-3 px-1 border-b-2 font-medium text-sm ${activeTab === 'calendar' ? 'active' : 'border-transparent text-gray-500 hover:text-gray-700 hover:border-gray-300'}">Lịch</button>
                        </nav>
                    </div>
                    <div class="content-area"></div>`;
                const contentArea = container.querySelector('.content-area');
                if (activeTab === 'calendar') {
                    const calDiv = document.createElement('div');
                    contentArea.appendChild(calDiv);
                    const calendar = new FullCalendar.Calendar(calDiv, { initialView: 'dayGridMonth', locale: 'vi', headerToolbar: { left: 'prev,next today', center: 'title', right: 'dayGridMonth,timeGridWeek,listWeek' }, events: response.data, height: 'auto' });
                    setTimeout(() => calendar.render(), 0);
                } else {
                    contentArea.classList.add('space-y-3');
                    if (activeTab === 'notes') {
                        if(response.data.length > 0) response.data.forEach(note => contentArea.appendChild(createNoteCard(note)));
                        else contentArea.innerHTML = `<p class="text-gray-500 text-center">Không có ghi chú nào.</p>`;
                    } else {
                        if(response.data.length > 0) response.data.forEach(reminder => contentArea.appendChild(createReminderCard(reminder)));
                        else contentArea.innerHTML = `<p class="text-gray-500 text-center">Không có lời nhắc nào.</p>`;
                    }
                }
            } else {
                container.classList.add('prose');
                container.innerHTML = marked.parse(response.data);
            }
        }
        function formatTimestamp(date) { return date.toLocaleString('vi-VN', { hour: '2-digit', minute: '2-digit', day: '2-digit', month: '2-digit', year: 'numeric' }); }
        
        // Modal Functions
        function showModal(title, bodyHtml, actionsHtml) {
            modalTitle.textContent = title;
            modalBody.innerHTML = bodyHtml;
            modalActions.innerHTML = actionsHtml;
            customModal.classList.remove('hidden');
            setTimeout(() => {
                modalContentContainer.classList.remove('scale-95', 'opacity-0');
                modalContentContainer.classList.add('scale-100', 'opacity-100');
            }, 10);
        }
        function hideModal() {
            modalContentContainer.classList.add('scale-95', 'opacity-0');
            modalContentContainer.classList.remove('scale-100', 'opacity-100');
            setTimeout(() => {
                customModal.classList.add('hidden');
            }, 200);
        }

        // --- Event Listeners ---
        document.getElementById('showSignup').addEventListener('click', (e) => { e.preventDefault(); document.getElementById('loginView').classList.add('hidden'); document.getElementById('signupView').classList.remove('hidden'); });
        document.getElementById('showLogin').addEventListener('click', (e) => { e.preventDefault(); document.getElementById('signupView').classList.add('hidden'); document.getElementById('loginView').classList.remove('hidden'); });
        document.getElementById('loginForm').addEventListener('submit', async (e) => { e.preventDefault(); try { await signInWithEmailAndPassword(auth, document.getElementById('loginEmail').value, document.getElementById('loginPassword').value); document.getElementById('authError').textContent = ''; } catch (error) { document.getElementById('authError').textContent = 'Email hoặc mật khẩu không đúng.'; } });
        document.getElementById('signupForm').addEventListener('submit', async (e) => { e.preventDefault(); try { await createUserWithEmailAndPassword(auth, document.getElementById('signupEmail').value, document.getElementById('signupPassword').value); document.getElementById('authError').textContent = ''; } catch (error) { document.getElementById('authError').textContent = 'Đăng ký thất bại. Email có thể đã tồn tại.'; } });
        document.getElementById('logoutButton').addEventListener('click', () => signOut(auth));
        
        sendPromptButton.addEventListener("click", handlePrompt);
        promptInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                handlePrompt();
            }
        });
        
        document.getElementById('quickActionAllNotes').addEventListener('click', () => {
            promptInput.value = 'hiển thị tất cả ghi chú';
            handlePrompt();
        });

        document.getElementById('quickActionAllReminders').addEventListener('click', () => {
            promptInput.value = 'hiển thị tất cả lời nhắc';
            handlePrompt();
        });

        chatContainer.addEventListener('click', async function(event) {
            const tabBtn = event.target.closest('.tab-btn');
            if (tabBtn) {
                const type = tabBtn.dataset.type;
                if (type === 'notes') promptInput.value = 'hiển thị tất cả ghi chú';
                else if (type === 'reminders') promptInput.value = 'hiển thị tất cả lời nhắc';
                else if (type === 'calendar') promptInput.value = 'hiển thị lịch';
                handlePrompt();
                return;
            }

            const editBtn = event.target.closest('.edit-btn');
            const deleteBtn = event.target.closest('.delete-btn');
            const editReminderBtn = event.target.closest('.edit-reminder-btn');
            const deleteReminderBtn = event.target.closest('.delete-reminder-btn');

            if (deleteBtn || deleteReminderBtn) {
                const isNote = !!deleteBtn;
                const id = isNote ? deleteBtn.dataset.noteId : deleteReminderBtn.dataset.reminderId;
                const typeText = isNote ? 'ghi chú' : 'lời nhắc';
                showModal(
                    `Xác nhận Xóa`,
                    `<p class="text-sm text-gray-500">Bạn có chắc chắn muốn xóa ${typeText} này không?</p>`,
                    `<button id="cancelDeleteBtn" class="px-4 py-2 bg-gray-200 text-gray-800 rounded-md hover:bg-gray-300">Hủy</button>
                     <button id="confirmDeleteBtn" class="px-4 py-2 bg-red-600 text-white rounded-md hover:bg-red-700">Xóa</button>`
                );
                document.getElementById('cancelDeleteBtn').onclick = hideModal;
                document.getElementById('confirmDeleteBtn').onclick = async () => {
                    hideModal();
                    setControlsEnabled(false);
                    appendTypingIndicator();
                    const result = isNote 
                        ? await agentFunctions.deleteNoteFromFirestore({ id })
                        : await agentFunctions.deleteReminderFromFirestore({ id });
                    appendAIMessage(result);
                    setControlsEnabled(true);
                };
            } else if (editBtn) {
                const id = editBtn.dataset.noteId;
                const currentText = editBtn.dataset.noteText;
                const currentPriority = editBtn.dataset.notePriority;
                showModal(
                    `Chỉnh sửa ghi chú`,
                    `<div class="space-y-4">
                        <div>
                            <label for="modalInputText" class="block text-sm font-medium text-gray-700">Nội dung</label>
                            <textarea id="modalInputText" class="mt-1 w-full p-2 border rounded-md">${currentText}</textarea>
                        </div>
                        <div>
                            <label for="modalInputPriority" class="block text-sm font-medium text-gray-700">Ưu tiên</label>
                            <select id="modalInputPriority" class="mt-1 w-full p-2 border rounded-md">
                                <option value="low" ${currentPriority === 'low' ? 'selected' : ''}>Thấp</option>
                                <option value="medium" ${currentPriority === 'medium' ? 'selected' : ''}>Trung bình</option>
                                <option value="high" ${currentPriority === 'high' ? 'selected' : ''}>Cao</option>
                            </select>
                        </div>
                    </div>`,
                    `<button id="cancelEditBtn" class="px-4 py-2 bg-gray-200 text-gray-800 rounded-md hover:bg-gray-300">Hủy</button>
                     <button id="confirmEditBtn" class="px-4 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700">Lưu</button>`
                );
                const modalInputText = document.getElementById('modalInputText');
                modalInputText.focus();
                document.getElementById('cancelEditBtn').onclick = hideModal;
                document.getElementById('confirmEditBtn').onclick = async () => {
                    const newText = modalInputText.value.trim();
                    const newPriority = document.getElementById('modalInputPriority').value;
                    if ((newText && newText !== currentText) || newPriority !== currentPriority) {
                        hideModal();
                        setControlsEnabled(false);
                        appendTypingIndicator();
                        const result = await agentFunctions.updateNoteInFirestore({ id, newText, newPriority });
                        appendAIMessage(result);
                        setControlsEnabled(true);
                    } else { hideModal(); }
                };
            } else if (editReminderBtn) {
                const id = editReminderBtn.dataset.reminderId;
                const currentTitle = editReminderBtn.dataset.reminderTitle;
                const currentTime = editReminderBtn.dataset.reminderTime;
                const currentPriority = editReminderBtn.dataset.reminderPriority;
                showModal(
                    `Chỉnh sửa lời nhắc`,
                    `<div class="space-y-4">
                        <div>
                            <label for="modalInputTitle" class="block text-sm font-medium text-gray-700">Nội dung</label>
                            <input type="text" id="modalInputTitle" class="mt-1 w-full p-2 border rounded-md" value="${currentTitle}">
                        </div>
                        <div>
                            <label for="modalInputTime" class="block text-sm font-medium text-gray-700">Thời gian</label>
                            <input type="datetime-local" id="modalInputTime" class="mt-1 w-full p-2 border rounded-md" value="${currentTime}">
                        </div>
                        <div>
                            <label for="modalInputPriority" class="block text-sm font-medium text-gray-700">Ưu tiên</label>
                            <select id="modalInputPriority" class="mt-1 w-full p-2 border rounded-md">
                                <option value="low" ${currentPriority === 'low' ? 'selected' : ''}>Thấp</option>
                                <option value="medium" ${currentPriority === 'medium' ? 'selected' : ''}>Trung bình</option>
                                <option value="high" ${currentPriority === 'high' ? 'selected' : ''}>Cao</option>
                            </select>
                        </div>
                    </div>`,
                    `<button id="cancelEditBtn" class="px-4 py-2 bg-gray-200 text-gray-800 rounded-md hover:bg-gray-300">Hủy</button>
                     <button id="confirmEditBtn" class="px-4 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700">Lưu</button>`
                );
                const modalInputTitle = document.getElementById('modalInputTitle');
                modalInputTitle.focus();
                document.getElementById('cancelEditBtn').onclick = hideModal;
                document.getElementById('confirmEditBtn').onclick = async () => {
                    const newTitle = modalInputTitle.value.trim();
                    const newTime = document.getElementById('modalInputTime').value;
                    const newPriority = document.getElementById('modalInputPriority').value;
                    if ((newTitle && newTitle !== currentTitle) || (newTime && newTime !== currentTime) || newPriority !== currentPriority) {
                        hideModal();
                        setControlsEnabled(false);
                        appendTypingIndicator();
                        const result = await agentFunctions.updateReminderInFirestore({ id, newTitle, newTime, newPriority });
                        appendAIMessage(result);
                        setControlsEnabled(true);
                    } else { hideModal(); }
                };
            }
        });

    </script>
</body>
</html>
